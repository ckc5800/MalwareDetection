import numpy as np
import sys
import os

try:
    caffe_root = '/home/mmlab/caffe/'
except KeyError:
    raise KeyError("Define CAFFE_ROOT in ~/.bashrc")

sys.path.insert(1, caffe_root + 'python/')
import caffe
import cv2
from py_returnCAMmap import py_returnCAMmap
from py_map2jpg import py_map2jpg
import scipy.io


def im2double(im):
    return cv2.normalize(im.astype('float'), None, 0.0, 1.0, cv2.NORM_MINMAX)
def model_set(model='googlenet', weight_path='model/googlenetCAM_malware_iter_160000.caffemodel', model_path='model/deploy_googlenetCAM_malware.prototxt') :
    if model == 'googlenet':
        net_weights = weight_path
        net_model = model_path
        out_layer = 'CAM_fc'
        crop_size = 224
        last_conv = 'CAM_conv'
    else:
        raise Exception('This model is not defined')

    return net_weights, net_model, out_layer, crop_size, last_conv
def load_model(net_model, net_weights, device) :
    # load CAM model and extract features
    caffe.set_device(device)
    caffe.set_mode_gpu()
    net = caffe.Net(net_model, net_weights, caffe.TEST)
    return net
def load_image(path) :
    img = cv2.imread(path)
    return img
def cam_heatmap(net, image, out_layer, crop_size, last_conv, virwhite) :
    transformer = caffe.io.Transformer({'data': net.blobs['data'].data.shape})
    transformer.set_transpose('data', (2, 0, 1))
    transformer.set_mean('data', np.load(caffe_root + 'python/caffe/imagenet/ilsvrc_2012_mean.npy').mean(1).mean(1))
    # transformer.set_channel_swap('data', (2,1,0))  # the reference model has channels in BGR order instead of RGB
    #transformer.set_mean('data', np.load('/media/mmlab/hdd/Malware/caffe_dataset/label/malware_mean.binaryproto').mean(1).mean(1))

    weights_LR = net.params[out_layer][0].data  # get the softmax layer of the network

    srcImg = image
    image = cv2.resize(image, (256, 256))

    # Take center crop.
    center = np.array(image.shape[:2]) / 2.0
    crop = np.tile(center, (1, 2))[0] + np.concatenate([
        -np.array([crop_size, crop_size]) / 2.0,
        np.array([crop_size, crop_size]) / 2.0
    ])
    crop = crop.astype(int)
    input_ = image[crop[0]:crop[2], crop[1]:crop[3], :]

    # extract conv features
    net.blobs['data'].reshape(*np.asarray([1, 3, crop_size, crop_size]))  # run only one image
    net.blobs['data'].data[...][0, :, :, :] = transformer.preprocess('data', input_)
    out = net.forward()
    scores = out['prob']
    activation_lastconv = net.blobs[last_conv].data

    ## Class Activation Mapping

    topNum = 5  # generate heatmap for top X prediction results
    scoresMean = np.mean(scores, axis=0)
    ascending_order = np.argsort(scoresMean)
    IDX_category = ascending_order[::-1]  # [::-1] to sort in descending order

    curCAMmapAll = py_returnCAMmap(activation_lastconv, weights_LR[IDX_category[:topNum], :])

    curResult = im2double(image)


    #curCAMmap_crops = curCAMmapAll[:, :, j]
    curCAMmap_crops = curCAMmapAll[:, :, virwhite]
    curCAMmapLarge_crops = cv2.resize(curCAMmap_crops, (256, 256))
    curHeatMap = cv2.resize(im2double(curCAMmapLarge_crops), (256, 256))  # this line is not doing much
    curHeatMap = im2double(curHeatMap)

    curHeatMap = py_map2jpg(curHeatMap, None, 'jet')
    curHeatMap = cv2.resize(curHeatMap, (srcImg.shape[0], srcImg.shape[1]))
    curHeatMap[:, :, 0] = 0
    curHeatMap[:, :, 1] = 0

    cv2.imwrite('heatmap.jpg', curHeatMap)

    bbox_threshold = [20, 100, 110]  # parameters for the bbox generator
    curParaThreshold = str(bbox_threshold[0]) + ' ' + str(bbox_threshold[1]) + ' ' + str(bbox_threshold[2]) + ' '

    curBBoxFile = 'CAM_ROI_Extractor/CAM_Python/bboxgenerator/heatmap_6.txt';

    os.system("CAM_ROI_Extractor/CAM_Python/bboxgenerator/./dt_box " + "heatmap.jpg" + ' ' + curParaThreshold + ' ' + curBBoxFile)

    with open(curBBoxFile) as f:
        for line in f:
            items = [int(x) for x in line.strip().split()]

    boxData1 = np.array(items[0::4]).T
    boxData2 = np.array(items[1::4]).T
    boxData3 = np.array(items[2::4]).T
    boxData4 = np.array(items[3::4]).T

    boxData_formulate = np.array([boxData1, boxData2, boxData1 + boxData3, boxData2 + boxData4]).T

    col1 = np.min(np.array([boxData_formulate[:, 0], boxData_formulate[:, 2]]), axis=0)
    col2 = np.min(np.array([boxData_formulate[:, 1], boxData_formulate[:, 3]]), axis=0)
    col3 = np.max(np.array([boxData_formulate[:, 0], boxData_formulate[:, 2]]), axis=0)
    col4 = np.max(np.array([boxData_formulate[:, 1], boxData_formulate[:, 3]]), axis=0)

    boxData_formulate = np.array([col1, col2, col3, col4]).T

    curImg = srcImg

    curHeatMap = im2double(curHeatMap)
    curHeatMap = py_map2jpg(curHeatMap, None, 'jet')

    #curHeatMap = im2double(curImg) * 0.2 + im2double(curHeatMap) * 0.7

    bbox_list = []
    for i in range(boxData_formulate.shape[0]):  # for each bbox
        #cv2.rectangle(curHeatMap, tuple(boxData_formulate[i][:2]), tuple(boxData_formulate[i][2:]), (255, 0, 0), 3)
        bbox = [boxData_formulate[i][0], boxData_formulate[i][1], boxData_formulate[i][2], boxData_formulate[i][3]]
        bbox_list.append(bbox)
    #cv2.imshow("test.jpg", curHeatMap)
    #cv2.waitKey(0)

    return bbox_list
def fwrite_xywh(roifile, bbox):
    rf = open(roifile, 'w')
    for nBox in range(len(bbox)):
        for j in range(len(bbox[nBox])):
            rf.write(str(bbox[nBox][j]) + "\t")
            rf.write("\n")
    rf.close()

